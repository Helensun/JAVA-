### 创建：

线程池，使用Executors或者直接创建

```
new ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler);
```

### 几个参数的含义：

1. corePoolSize:核心线程数，有活先给core干
2. maxPoolSIze:corePoolSize+非核心线程数
3. keepAliveTime:线程存活时间
4. workQueue：core满时，需要加入队列
5. threadFactory：创建线程的线程工厂
6. handler：拒绝策略

### 线程池执行流程：

![](https://img-blog.csdn.net/2018041900353665)

### handler的拒绝策略：

有四种：第一种AbortPolicy:不执行新任务，直接抛出异常，提示线程池已满

​       第二种DisCardPolicy:不执行新任务，也不抛出异常

​       第三种DisCardOldSetPolicy:将消息队列中的第一个任务替换为当前新进来的任务执行

​       第四种CallerRunsPolicy:直接调用execute来执行当前任务

### 几个问题：

**Q. 线程池是什么时候创建线程的？**

*A.任务提交的时候*

**Q.任务runnable task是先放到core到maxThread之间的线程，还是先放到队列？**

*A.先放队列!!!*

**Q. 队列中的任务是什么时候取出来的？**

A. worker中 runWorker() 一个任务完成后，会取下一个任务

**Q. 什么时候会触发reject策略？**

A.队列满并且maxthread也满了， 还有新任务，默认策略是reject

**Q. core到maxThread之间的线程什么时候会die?**

A. 没有任务时，或者抛异常时。  

  core线程也会die的，core到maxThread之间的线程有可能会晋升到core线程区间，

  core max只是个计数，线程并不是创建后就固定在一个区间了

**Q. task抛出异常，线程池中这个work thread还能运行其他任务吗?**

A. 不能。 但是会创建新的线程, 新线程可以运行其他task。

对于 schedulerThreadPoolExecutor?  虽然有新线程，但是旧的循环任务不会再继续执行了， 开发实践推荐任务中捕获所有Exception

### 易错点：

线程池中的corePoolSize就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收，maximumPoolSize就是线程池中可以容纳的最大线程的数量，而keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间，而util，就是计算这个时间的一个单位，workQueue，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。threadFactory，就是创建线程的线程工厂，最后一个handler,是一种拒绝策略，我们可以在任务满了知乎，拒绝执行某些任务。

1. 

## 常见线程池

## CachedThreadPool

ExecutorService e = Executors.newCachedThreadPool()

底层：

ThreadPoolExecutor(

0, 

Interger.MAX_VALUE， 

60L， 

TimeUnit.SECONDS, 

new synchronousQueue<Runnable>() 

)

## FixedThreadPool

new的时候规定大小

ExecutorService e = Executors.newFixedThreadPool()

底层：

ThreadPoolExecutor(

**arg1**, 

**arg1**， 

0L， 

TimeUnit.MILLISECONDS, 

new LinkedBlockingsQueue<Runnable>() 

)

arg1是传入参数

LinkedBlockingQueue是无限大的

同步队列大小为0，也就是不存数据。

## SingleThreadExecutor

大小只有1的FixedThreadPool

ExecutorService e = Executors.newSingleThreadExecutor()

>  其实都是ThreadPoolExcutor,只是传入参数不同
>
> 构造方法
>
> ThreadPoolExecutor（
>
> int corePoolSize,  核心池大小*
>
> int maximumPoolSize,  总池子大小*
>
> long keepAliveTime, 时间*
>
> TimeUnit unit, 时间单位
>
> BlockingQueue<Runnable> workQueue, 阻塞队列*
>
> ThreadFactory threadFactory,生成线程的线程工厂
>
>  RejectExcutionHandler handler 当拒绝执行时的处理函数
>
> )
>
> 加*的是重点
