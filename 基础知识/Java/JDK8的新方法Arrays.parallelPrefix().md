以int类型举例，其他类型原理区别不大。

先看jdk官方文档对parallelPrefix的描述

```java
 /**
  * Cumulates, in parallel, each element of the given array in place,
  * using the supplied function. For example if the array initially
  * holds {@code [2, 1, 0, 3]} and the operation performs addition,
  * then upon return the array holds {@code [2, 3, 3, 6]}.
  * Parallel prefix computation is usually more efficient than
  * sequential loops for large arrays.
  */
```

使用提供的功能，并行地计算给定阵列的每个元素。 例如，如果阵列最初保持`[2, 1, 0, 3]`并且操作执行添加，则返回时，数组将保持`[2, 3, 3, 6]` 。 并行前缀计算通常比大数组的顺序循环更有效。

- **参数**

  `array` - 通过此方法就地修改的数组

  `op` - 执行累积的无副作用的关联函数

```javascript
[2,1,0,3]-->[2,3,3,6]的过程

		2			1			0			3
-->		2			1+2=3		0+3=3		3+3=6
--> 	2			3			3			6
```

再找一个复杂的例子，以下内容借鉴https://cloud.tencent.com/developer/ask/196804/answer/306796

```javascript
4    9    5    1    0    5    1    6    6    4    6    5    1    6    9    3  
```

```javascript
 4 → 13 → 18 → 19    0 →  5 →  6 → 12    6 → 10 → 16 → 21    1 →  7 → 16 → 19  
                 ↓                   ↓                   ↓                   ↓  
                19                  12                  21                  19  
```

首先利用关联性将前缀操作应用于偏移量

```javascript
                 ↓                   ↓                   ↓                   ↓  
                19         →        31         →        52         →        71  
```

然后，我们进入第二阶段，即将这些偏移量应用于下一个块的每个元素，这是一个完全可并行化的操作，因为不再依赖于前一个元素。

```javascript
                     19   19   19   19   31   31   31   31   52   52   52   52  
                      ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓  
  4   13   18   19   19   24   25   31   37   41   47   52   53   59   68   71  
```

当我们对八个线程使用相同的示例时，

```javascript
  4    9    5    1    0    5    1    6    6    4    6    5    1    6    9    3  

  4 → 13    5 →  6    0 →  5    1 →  7    6 → 10    6 → 11    1 →  7    9 → 12  
       ↓         ↓         ↓         ↓         ↓         ↓         ↓         ↓  
      13         6         5         7        10        11         7        12  

       ↓         ↓         ↓         ↓         ↓         ↓         ↓         ↓  
      13    →   19    →   24    →   31    →   41    →   52    →   59    →   71  

           13   13   19   19   24   24   31   31   41   41   52   52   59   59  
            ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓  
  4   13   18   19   19   24   25   31   37   41   47   52   53   59   68   71  
```

我们看到有一个明显的好处，即使我们使用更简单的策略来保持两个步骤的工作块相同，换句话说，在第二阶段接受一个空闲工作线程。对于第一阶段我们将需要大约⅛n而对于第二阶段需要⅛n，需要总共需要¼n（其中*n*是整个阵列的顺序前缀评估的成本）。当然，只有粗略和最好的情况。

相比之下，当我们只有两个处理器

```javascript
  4    9    5    1    0    5    1    6    6    4    6    5    1    6    9    3  


  4 → 13 → 18 → 19 → 19 → 24 → 25 → 31    6 → 10 → 16 → 21 → 22 → 28 → 37 → 40  
                                     ↓                                       ↓  
                                    31                                      40  

                                     ↓                                       ↓  
                                    31                   →                  71  

                                         31   31   31   31   31   31   31   31  
                                          ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓  
  4   13   18   19   19   24   25   31   37   41   47   52   53   59   68   71  
```

当我们重新分配第二阶段的工作时，我们只能获益。如上所述，这是可能的，因为第二阶段的工作不再具有元素之间的依赖性。因此我们可以任意拆分此操作，但它会使实现复杂化并可能引入额外的开销。

当我们在两个处理器之间分配第二阶段的工作时，第一阶段需要大约½n而第二阶段需要¼n，总共产生n，如果阵列足够大，这仍然是一个好处。

作为补充说明，您可能会注意到在准备第二阶段时计算的偏移量与块的最后一个元素的结果相同。因此，您只需分配该值，即可将每个块所需的操作数减少一个。但典型的情况是只有少量块（使用处理器数量进行扩展）具有大量元素，因此每个块保存一个操作是不相关的。