7.jvm的内存分区

8.jvm堆和栈的区别

9.hashmap和hashtable的区别

10.concurrentmap说一下

11.arrayList和LinkedList,arrayList数据不断的增加会怎么样

12.反射了解吗，说一下？

**反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。**



13.java线程同步有几种，分别介绍一下，volatile介绍一下

14.http请求相关的过程

15.tcp和udp的区别，为什么tcp更可靠，tcp一定就不会丢包吗？



第一题：合并两个有序数组（ https://leetcode-cn.com/problems/merge-sorted-array/）以及时间复杂度。做完以后面试官又问如果合并k个呢，我说了两两合并，然后时间复杂度是logk*(nk)，但是好像他说时间复杂度不对。然后又问我有没有更好的办法，我说没有 😥 

 第二题：[合并区间]()（https://leetcode-cn.com/problems/merge-intervals/）。  

```
比如：intervals = [[1,3],[2,6],[8,10],[15,18]]合并成 [[1,6],[8,10],[15,18]]
```





 \2. 进程和线程区别 

一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.



 \3. 进程和线程的切换上下文 

 \4. 上下文指什么 

某一时间点CPU寄存器和程序计数器的内容，被称为上下文。



 \5. 线程之间同步的机制 

管道、套接字、共享内存、消息队列、信号量



 \6. 物理地址和虚拟地址的区别 

 \7. 为什么要分成物理地址和虚拟地址 

 \8. 逻辑地址呢？

一个虚拟地址，大小4个字节(32bit)，包含着找到物理地址的信息，分为3个部分：
第22位到第31位这10位（最高10位）是页目录中的索引，
第12位到第21位这10位是页表中的索引，
第0位到第11位这12位（低12位）是页内偏移。
从这个解释来看 虚拟地址应该是线性地址 是由逻辑地址加段地址而来



 \9. 虚拟地址转换为物理地址的过程 

 \10. 快表是存储在哪里的 

cpu的专用寄存器中

1、快表TLB： 用于虚拟存储技术，是为了加快辅存向主存的地址映射速度（主存—辅存系统）
2、高速缓存器cache：用于解决CPU与主存速度不匹配问题。（CPU—主存系统）
2.1、cache补充：因为CPU速度远高于主存，主存跟不上，导致CPU的大量时间在等待主存，效率低下。因为cache速度介于CPU与主存之间，价格也介于两者之间，所以人们在CPU与主存之间添加“高速缓冲器cache”来缓解速度不匹配问题。
总的来说，两者属于两个不同的系统层次，功能也不同。



 \11. 计网5层模型和7层模型 

 \12. 应用层协议有什么 

1、DNS：域名系统DNS是因特网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。

现在顶级域名TLD分为三大类：国家顶级域名nTLD；通用顶级域名gTLD;基础结构域名

域名服务器分为四种类型：根域名服务器；顶级域名服务器；本地域名服务器；权限域名服务器。

2、FTP：文件传输协议FTP是因特网上使用得最广泛的文件传送协议。FTP提供交互式的访问，允许客户指明文件类型与格式，并允许文件具有存取权限。FTP其于TCP。

3、telnet远程终端协议：telnet是一个简单的远程终端协议，它也是因特网的正式标准。又称为终端仿真协议。

4、HTTP：超文本传送协议，是面向事务的应用层协议，它是万维网上能够可靠地交换文件的重要基础。http使用面向连接的TCP作为运输层协议，保证了数据的可靠传输。

5、电子邮件协议SMTP：即简单邮件传送协议。SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。SMTP通信的三个阶段：建立连接、邮件传送、连接释放。

6、POP3：邮件读取协议，POP3(Post Office Protocol 3)协议通常被用来接收电子邮件。

7、远程登录协议(Telnet)：用于实现远程登录功能。



 \13. 输入网址发送请求到接受响应的过程 

1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;

2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;

3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;

4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;

5、释放 TCP连接;

6、浏览器将该 html 文本并显示内容;



 \14. 网络拥堵可能有什么原因 

带宽不足，报文积压

 \15. TCP拥塞避免[算法]()

慢开始、拥塞避免、快重传、快恢复

 \16. 延迟ACK了解么？

### **1.Delayed Ack**

tcp协议规定在接受到数据段时需要向对方发送一个确认,但如果只是单纯的发送一个确认,代价会比较高(20字节的ip首部,20字节的tcp首部),最好能附带响应数据一起发送给对 方.所以tcp在何时发送ack给对方有以下规定:

1) 当有响应数据要发送时,ack会随响数据立即发送给对方.

2) 如果没有响应数据,ack的发 送将会有一个延迟,以等待看是否有响应数据可以一起发送 ,这称是"Delayed Ack".但这个延迟最多不会超过500ms,一般为200ms.如果在200ms内有数据要发送,那么ack会随数据一起立即发送给对方.注意这里的延迟200ms,不是指的从接受到对方数据到发送ack的最长等待时间差.而是指的内核启动的一个定时器,它每隔200ms就查看下是否有ack要发送.例如:假设定时器在0ms时启动,对方的数据段在

185ms时到达,那么ack最迟会在200ms时发送,而不是385ms时发送.

3) 如果在等待发送ack期间,对方的第二个数据段又到达了,这时要立即发送ack.但是如果对方的三个数据段相继 到达,那么第二个数据段到达时ack立即发送,但第三个数据段到达时是否立即发送,则取决于上面两条.





 \17. ipv6和ipv4的区别

 \18. redis为什么可以做分布式锁

Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系。

代码实现的，主要是针对某一笔数据的流水号加锁，防止多个线程写入这个数据。（具有互斥性）



 \19. 介绍一下redis单线程模型

Redis 是非阻塞的通过**IO 多路复用程序** 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。



 \20. redis过期策略

常用的过期数据的删除策略就两个

1. **惰性删除** ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
2. **定期删除** ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。

定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 **定期删除+惰性/懒汉式删除** 。

但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。

怎么解决这个问题呢？答案就是： **Redis 内存淘汰机制。**

Redis 提供 6 种数据淘汰策略：

1. **volatile-lru（least recently used）**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru（least recently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0 版本后增加以下两种：

1. **volatile-lfu（least frequently used）**：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
2. **allkeys-lfu（least frequently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key



 \21. MySQL的索引类型有什么 

BTree索引、Hash索引

聚集索引、非聚集索引

唯一索引、普通索引、复合索引



 \22. 联合索引是什么 

多列值组成一个索引，专门用于组合搜索，其效率大于索引合并



 \23. 怎么使用到联合索引 

 \24. 为什么使用联合索引要符合最左前缀匹配 

 \25. B树和B+树区别 

 \26. java泛型原理

二、Java泛型实现原理：类型擦出

​    Java的泛型是伪泛型。在编译期间，所有的泛型信息都会被擦除掉。正确理解泛型概念的首要前提是理解类型擦出（type erasure）。

​    Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。

  如在代码中定义的List<object>和List<String>等类型，在编译后都会编程List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方法与C++模版机制实现方式（后面介绍）之间的重要区别。

三、类型擦除后保留的原始类型

  原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。

 

 \27. java注解原理

而解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。反射的事情我们待会说，而编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。

典型的就是注解 @Override，一旦编译器检测到某个方法被修饰了 @Override 注解，编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中是否具有一个同样的方法签名。

这一种情况只适用于那些编译器已经熟知的注解类，比如 JDK 内置的几个注解，而你自定义的注解，编译器是不知道你这个注解的作用的，当然也不知道该如何处理，往往只是会根据该注解的作用范围来选择是否编译进字节码文件，仅此而已。





 \28. hashtable和hashmap区别 

 \30. 说一下常用的设计模式 

  \31. 单例模式怎么实现

```
public class Singleton4 {
    //构造方法
    private Singleton4(){}
    //私有静态成员对象
    private static volatile Singleton4 instance = null;
    //共有静态方法
    public static synchronized Singleton4 getInstance(){
        if (instance == null) {
            //只需要在第一次初始化的时候使用同步代码块，提高了程序的效率
            synchronized (Singleton4.class) {
                if (instance == null) {
                    instance = new Singleton4();
                }
            }
        }
        return instance;
    }
}
```

写个代码验证大端小端

```java
public class demo {
 
    /**
     * @param args
     */
    public static void main(String[] args) throws Exception {
        // TODO Auto-generated method stub
        int a = 0x12345678;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(baos);
        dos.writeInt(a);
        byte[] b = baos.toByteArray();
        for(int i = 0;i<4;i++){
            System.out.println(Integer.toHexString(b[i]));
        }    
    }
}
```



```java
long a = UNSAFE.allocateMemory(8);
        try {
            UNSAFE.putLong(a, 0x0102030405060708L);
            //存放此long类型数据，实际存放占8个字节，01,02,03，04,05,06,07,08
            byte b = UNSAFE.getByte(a);
            //通过getByte方法获取刚才存放的long，取第一个字节
            //如果是大端，long类型顺序存放—》01,02,03,04,05,06,07,08  ，取第一位便是0x01
            //如果是小端，long类型顺序存放—》08,07,06,05,04,03,02,01  ，取第一位便是0x08
            switch (b) {
                case 0x01:
                    ByteOrder byteOrder = ByteOrder.BIG_ENDIAN;
                    break;
                case 0x08:
                    byteOrder = ByteOrder.LITTLE_ENDIAN;
                    break;
                default:
                    assert false;
                    byteOrder = null;
            }
        }catch (Exception e){

        }

```



3.http的get和post请求（我答了不能存在书签等等），就具体的细问了一点

4.mysql引擎 区别

innoDB支持事务和行锁



6.进程 线程

### **2.区别**

1. 进程是资源分配的基本单位；线程是程序执行的基本单位。
2. 进程拥有自己的资源空间，没启动一个进程，系统就会为它分配地址空间；而线程与CPU资源分配无关，多个线程共享同一进程内的资源，使用相同的地址空间。
3. 一个进程可以包含若干个线程。

### **3. 优劣**

正是因为这二者有区别，所以带来的各自的优劣

1. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（Inter Process Communication，IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
2. 线程的调度与切换比进程快很多，同时创建一个线程的开销也比进程要小很多。
3. 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。



7.io多路复用



2.HashMap底层实现，扩容阈值，具体怎么扩容，扩容优化，抖动函数，集合大小为什么是2的幂，为什么阈值是8（[源码]()里是8-1），jkd1.7,1.8具体优化的地方。 
 3.线程安全集合，ConcurrentHashMap,具体实现，jdk1.7,jkd1.8区别，分段锁，锁粒度，好像答的不够多，然后又挤出来一个计数方法，1.8计数特别麻烦。 
 4.多线程相关，volatile原理，JMM，synchronize优化（还讲了对象头markword 和类元指针），reentrantlock原理，AQS。 
 5.final修饰类 方法 属性区别。 
 7.堆区域的划分，垃圾回收[算法]()，标记[算法]()，内存分配[算法]()（和垃圾回收器相关）。 
 9.方法区，元空间。 具体怎么优化解决STW问题。 
 10.对象的所有过程，创建销毁，加载连接初始化，分配内存CAS（还讲了TLAB参数），具体怎么移动到老年代（15），还讲了具体操作数栈中的过程，内存泄漏。 
 11.CMS 和 G1相关也讲了一下。 
 12.ThreadLocal原理，里面的map具体怎么实现的，和hashmap的不同，内存泄漏问题，具体应用场景。 
 15.四个隔离级别，每个级别分别解决了什么问题，讲了默认隔离级别和常用隔离级别。 
 16.gap lock, record lock ,next key lock。 
 17.MVCC怎么实现的，解决了什么问题，undolog讲了一点。 
 18.B+树讲了一点。 
 19.脏读 幻读，讲一下幻读场景。 
 20.[redis]()持久化，讲了aop rdb，具体场景，两者一起用，cow和fork，aof瘦身。 
 21.缓存雪崩 缓存穿透（好像和击穿弄混了），布隆过滤器。 

布隆过滤器：位图+hash

 22.[redis]() zset，跳跃表，为什么不用[红黑树]()，跳跃表实现讲了一下。 
 23.分布式锁。答了incr,set,setnx，redlock。 
 27.[redis]()集群相关，讲了哨兵，主从，集群，选举Leader，掉线了会发生什么，脑裂，hash一致性[算法]()（讲了虚拟结点），哨兵之间订阅沟通还有一些不记得了。 
 28.AOP原理，IOC原理。循环依赖。CGLIB,JDK proxy，讲了底层缓存，之间的区别。



 mysql 最左前缀原则 

 事务引发的问题 

 mysql 的 RR 级别实现（一致性视图） 

 SQL 的部分调优 

 Redis 的基本数据结构与RedisObject 

 [算法]()：[leetcode 721 账户合并](https://leetcode-cn.com/problems/accounts-merge/)



 Java 里面的锁 

 Java 多态 

 HashMap 中[链表]()与红黑数的互相转换，三个参数，三种情况（扩容与remove都会导致退化） 

 创建对象的几种方式 

1.用new语句创建对象,这是最常用的创建对象的方式。

2.运用反射手段,调用Java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。

3.调用对象的clone()方法。

4.运用反序列化手段,调用java.io.ObjectInputStream对象的readObject()方法.



 创建对象的过程（类加载等） 

1. 加载 2.连接（验证、准备、解析） 3. 初始化

 jdk 动态代理与 cglib 动态代理的区别 

 两种代理模式哪种更有优势，在哪里体现的




 synchronized 是怎么实现的（这里自己根据锁升级、markword、monitorObject进行了对应的回答） 

 AQS 系列，CLH锁，加锁的流程 

 CAS 怎么实现的（底层实现，这里只是回答到了原语的那部分，自己还得再挖一层） 

 CAS 的不足 

 内存置换[算法]() 

 说下熟悉的垃圾回收器（CMS、G1） 

 GCRoot 都有哪些 

 [算法]()：因为时间的原因，简单问了下快排的实现，最好、最坏、平均时间复杂度以及对应的情况



怎么建立索引（怎么建比较好） 

怎么对进行不同用户进行权限控制 

你用Redis做了什么？Redis和MySQL数据不同步怎么办? 

你所了解的数据库连接池，能说说常用的数据库连接池吗？ 

MySQL的事务 

分布式事务了解过吗? 

Redis的缓存穿透和缓存雪崩 

HashMap的底层实现 

Java多线程的线程安全问题 

Java异常 

Spring的IOC和AOP 

用过的日志组件 

说说log4j的日志级别



3、[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)的rehash

4、mysql的主键索引和聚簇索引的区别

5、sql语句太慢怎么办

6、问了ArrayList和LinkedList的区别

7、写一个栈



1 有序数组[排序]()，二分，复杂度 

 2 常见[排序]()[算法]()，说下快排过程，时间复杂度 

 3 有N个节点的满[二叉树]()的高度。1 logN 

 4 朋友之间的点对点关系用图维护，怎么判断两人是否是朋友，并查集，时间复杂度，过程。没讲清楚 

 \1. 初始化元素 

 \2. 实现元素与元素间的联合操作 

 \3. 实现查找元素所在树的根节点 

 \4. 解决一个问题，判定两个元素是否在同一棵树上（两个元素是否相互连接） 

 5 单元点最短路的方法，时间复杂度 

 6 如何实现关键字输入提示，使用字典树，复杂度多少，有没有其他方案，答哈希，如果是中文呢，分词后建立字典树？ 

 7 hashmap的实现讲一下吧，讲的很详细了。讲一下[红黑树]()的结构，查询性能等。 

 8 Java中的垃圾回收讲一下，讲了分代，gc[算法]()，gc root可达性分析等 

 9 讲一下两个[项目]()你都做了什么把。 

 10 除了代码之外你还学习了什么技术，框架。 

 11 死锁是怎么产生的 

 12 线程和进程的区别 

 13 进程的通信方式 

 14 CPU的执行方式 

 15 代码中遇到进程阻塞，进程僵死，内存泄漏等情况怎么排查。通过ps查询状态，分析dump文件等方式排查。 

 16 Linux了解么，查看进程状态ps，查看cpu状态 top。查看占用端口的进程号netstat grep 

 17 10g文件，只有2g内存，怎么查找文件中指定的字符串出现位置。MapReduce分割文件处理。 

 他说可以用cat | grep 管道处理。



1 介绍一下[项目]() 

 2 你谈到的并发技术，chm和countdownlatch怎么使用的 

 3 为什么要这么处理，使用线程池是不是也可以。我说也可以 

 4 操作系统的进程通信方式，僵尸进程和孤儿进程是什么，如何避免僵尸进程，我说让父进程显示通知，那父进程怎么知道子进程结束了，答不会。 

 5 计算机网络TCP和UDP有什么区别，为什么[迅雷]()下载是基于UDP的，我说FTP是基于TCP，而[迅雷]()是p2p不需要TCP那么可靠的传输保证。 

 6 他说不对，我说是不是因为要建立连接，开销比较大，他说不对 

 7 我说p2p的发送节点很多，所以不是那么需要各种传输保证，他说不对。 

 8 我说TCP会自动分包而TCP可以自己定义数据长度。。他还是说不对。 

 最后他说算了。我们问下一个吧。 

   

 9 操作系统的死锁必要条件，如何避免死锁。 

 10 写一个LRU的缓存，需要完成超时淘汰和LRU淘汰。 

 我说用lhm行不行，他说用linkedlist和hashmap可以。 

 于是我就写了put和get函数，进行了队头队尾操作。 

 他说get复杂度会不会太高，我瞎掰了半天没找到办法，他说那就这样吧，今天面试到这。



稍微讲一下 Spring 、Redis 的了解，挑一块自己了解得比较深的地方 

 我调了 IOC 容器整个初始化过程，讲到了 customize 方法来配置循环依赖与 Bean 覆盖   

1.  打断了问 Spring 如何解决循环依赖 

 Bean 工厂的扩展机制（我也不太清除这问的是什么，我回答了 postProcessBefore... / after....） 

 postProcessBefore... / after.... 有什么运用 

 Redis 的运用 

 Redis 的基本数据结构和实现方式 

 Redis 的持久化   

1.  RDB 的实现看过吗 

 Redis 集群的实现方式 



进程 线程 协程 

进程通信 

常见的信号有哪些 

进程状态 

CPU内存模型 

内存淘汰机制 

用户态和系统态 

如何查看进程在用户态和系统态的占用 

进程调度[算法]() 

如何解决并发数据不一致 

TCP可靠性 

TCP拥塞控制 

如何使用socket实现可靠连接 

TCP四次挥手，2MSL，各种状态，服务端是否可以为timewait状态 

服务端-[客户端]()，[客户端]()长时间没有回应，如何处理，默认断开时间 

服务端-[客户端]()，什么情况大量[客户端]()处于timewait状态，会有什么状况 

服务端-路由器-[客户端]()，路由器挂了会怎么办，能否重连，如何实现 

TCP报文有哪些 

UDP常见应用 

如何查看连接处于何种状态 

HTTP请求结构，如何分割 

HTTP请求方法有哪些 

如何判断返回数据格式 

[keep]()-alives是否一致连接， User-Agent 

API 设计规范（[RESTful](https://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html)） 

create table 

索引 

node大小，如何选择 

索引类型 

主键索引和其他索引区别，结构上有什么区别 

事务隔离 

[redis]()数据结构 

[redis]() hash扩容 

手写单例



手写LRU

- 实现
- 定时机制实现



3.java八种基本数据类型

4.垃圾回收

5.redis数据结构

6.sorted set应用场景

7.redis持久化

8.mysql事务

9.mysql隔离级别

10.mysql在可重复读隔离级别下怎么解决幻读

11.mysql聚集索引与非聚集索引

12.https原理

13.tcp三次握手，为什么不能是两次

14.进程通信

15.虚拟内存是什么

16.COW如何实现

17.top命令，netstat命令

18.ReentrantLock 与 synchronized 区别

19.线程池满了处理策略

20.消息队列有了解吗

力扣 678. 有效的字符串 没写出来

挂



第二次一面 TEG 电话面试

1.自我介绍

2.项目相关

3.git的一些基本命令

4.liunx的一些基本命令

5.java垃圾回收机制

6.二叉树有哪些

7.HashMap底层如何实现

8.mysql索引

9.TCP与UDP区别

10.TCP三次握手

11.redis为什么快

12.Liunx多路复用机制

还有一些不记得了  挂



第三次一面 CSIG 腾讯会议

1.自我介绍

2.OSI七层模型

3.应用层有哪些协议

4.TCP与UDP区别

5.Https加密过程

6.长连接与短连接 长连接如何实现 怎么将连接设置为短连接

7.mysql MyIsam与InnoDB的区别

8.[牛客的课程订单分析(六)_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/c5736983c322483e9f269dd23bdf2f6f?tpId=82&rp=1&ru=%2Fta%2Fsql&qru=%2Fta%2Fsql%2Fquestion-ranking&tab=answerKey) 没有完整写出来

9.进程与线程区别

10.进程间通信

11.数据与链表区别

12.哈希冲突解决

13.给了三个类计算类的占用空间，主要是考虑内存对齐

14.手写快排

```java
public class LRUCache<K,V> {
    class Node<K,V> {
        K key;
        V value;
        Node<K,V> prev, next;
        public Node(){}
        public Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    private int capacity;
    private HashMap<K,Node> map;
    private Node<K,V> head;
    private Node<K,V> tail;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>(capacity);
        head = new Node<>();
        tail = new Node<>();
        head.next = tail;
        tail.prev = head;
    }

    public V get(K key) {
        Node<K,V> node = map.get(key);
        if (node == null) {
            return null;
        }
        moveNodeToHead(node);
        return node.value;
    }

    public void put(K key, V value) {
         Node<K,V> node = map.get(key);
       if (node == null) {
            if (map.size() >= capacity) {
                map.remove(tail.prev.key);
                removeTailNode();
            }
            Node<K,V> newNode = new Node<>(key, value);
            map.put(key, newNode);
            addToHead(newNode);
        } else {
            node.value = value;
            moveNodeToHead(node);
        }
    }

    private void addToHead(Node<K,V> newNode) {
        newNode.prev = head;
        newNode.next = head.next;
        head.next.prev = newNode;
        head.next = newNode;
    }

    private void moveNodeToHead(Node<K,V> node) {
        removeNode(node);
        addToHead(node);
    }

    private void removeNode(Node<K,V> node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void removeTailNode() {
        removeNode(tail.prev);
    }

    public static void main(String[] args) {
        LRUCache<Integer,Integer> lruCache = new LRUCache<>(3);
        lruCache.put(1,1);
        lruCache.put(2,2);
        lruCache.put(3,3);
        lruCache.get(1);
        lruCache.put(4,4);
        System.out.println(lruCache); // toString 我就没贴了，代码太长了
    }
}
```



手写生产者消费者

1.http1.0，http1.1，http2.0的区别 
 2.短连接适用在什么场景 
 3.并发的时候长连接会出现什么问题 
 4.怎么来解决长连接的这种问题 
 5.怎么来保证高可用性？(答了负载均衡和缓存) 
 6.ngnix的底层原理 
 7.为什么[redis]()这么快 
 8.[项目]()用[redis]()做了什么 
 9.知道哪些存储引擎 
 10.什么场景下用innoDB 
 11.索引失效情况 
 12.Hashmap，Hashtable，ConcurrentHashmap的区别 
 13.java多线程实现方式 
 14.每种实现方式的使用场景说一下 
 15.辣鸡回收[算法]()都说一下(不要回收我) 
 16.Synchronized和lock的区别 
 17.sql注入原理 
 18.一亿个数怎么找最大的10万个，时间复杂度多少 
 19.本地IDE写[算法题]()twoSum，秒解 
 前面短连接/长连接差点问哭我，没背啊，面完显示过了