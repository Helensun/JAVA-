# java的重写规则。
### 原则：对于异常重写方法不能抛出新的异常或者比被重写方法声明的检查异常更广的检查异常。但是可以抛出更少，更有限或者不抛出异常。

## 重写规则之一：重写方法不能比被重写方法限制有更严格的访问级别。
（但是可以更广泛，比如父类方法是包访问权限，子类的重写方法是public访问权限。） 比如：Object类有个toString()方法，开始重写这个方法的时候我们总容易忘记public修饰符，编译器当然不会放过任何教训我们 的机会。出错的原因就是：没有加任何访问修饰符的方法具有包访问权限，包访问权限比public当然要严格了，所以编译器会报错的。
## 重写规则之二： 参数列表必须与被重写方法的相同。
重写有个孪生的弟弟叫重载，也就是后面要出场的。如果子类方法的参数与父类对应的方法不同，那么就是你认错人了，那是重载，不是重写。
## 重写规则之三：返回类型必须与被重写方法的返回类型相同。
父类方法A：void eat(){} 子类方法B：int eat(){} 两者虽然参数相同，可是返回类型不同，所以不是重写。
父类方法A：int eat(){} 子类方法B：long eat(){} 返回类型虽然兼容父类，但是不同就是不同，所以不是重写。
## 重写规则之四：重写方法不能抛出新的异常或者比被重写方法声明的检查异常更广的检查异常。但是可以抛出更  少，更有限或者不抛出异常。
* 注意：这种限制只是针对检查异常，至于运行时异常RuntimeException及其子类不再这个限制之中。
## 重写规则之五： 不能重写被标识为final的方法。
## 重写规则之六：如果一个方法不能被继承，则不能重写它。如private方法
