# java的重写规则
### 原则：对于异常重写方法不能抛出新的异常或者比被重写方法声明的检查异常更广的检查异常。但是可以抛出更少，更有限或者不抛出异常。

## 重写规则之一：重写方法不能比被重写方法限制有更严格的访问级别。
（但是可以更广泛，比如父类方法是包访问权限，子类的重写方法是public访问权限。） 比如：Object类有个toString()方法，开始重写这个方法的时候我们总容易忘记public修饰符，编译器当然不会放过任何教训我们 的机会。出错的原因就是：没有加任何访问修饰符的方法具有包访问权限，包访问权限比public当然要严格了，所以编译器会报错的。
## 重写规则之二： 参数列表必须与被重写方法的相同。
重写有个孪生的弟弟叫重载，也就是后面要出场的。如果子类方法的参数与父类对应的方法不同，那么就是你认错人了，那是重载，不是重写。
## 重写规则之三：返回类型必须与被重写方法的返回类型相同或是其子类。
父类方法A：void eat(){} 子类方法B：int eat(){} 两者虽然参数相同，可是返回类型不同，所以不是重写。
父类方法A：int eat(){} 子类方法B：long eat(){} 返回类型不同，且long不是int子类，所以不是重写。
## 重写规则之四：重写方法不能抛出新的异常或者比被重写方法声明的检查异常更广的检查异常。但是可以抛出更少，更有限或者不抛出异常。
* 注意：这种限制只是针对检查异常，至于运行时异常RuntimeException及其子类不再这个限制之中。
## 重写规则之五：不能重写被标识为final的方法。
## 重写规则之六：如果一个方法不能被继承，则不能重写它。如private方法

# JAVA重载规则
### 原则在Java中，同一个类中的多个方法可以有相同的名字，只要它们的参数列表不同就可以，这被称为方法重载(method overloading)。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。
## 说明：
参数列表不同包括：个数不同、类型不同和顺序不同。
仅仅参数变量名称不同是不可以的。
跟成员方法一样，构造方法也可以重载。
声明为final的方法不能被重载。
声明为static的方法不能被重载，但是能够被再次声明。
## 方法的重载的规则：
方法名称必须相同。
参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）。
方法的返回类型可以相同也可以不相同。
仅仅返回类型不同不足以成为方法的重载。
## 方法重载的实现：
方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错，这叫做重载分辨。
